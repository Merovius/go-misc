// This file is automatically generated by merovius.de/go-misc/cmdgo-lazy.

package lazy

import (
	"sync"
	"sync/atomic"
)

// lazyBool implements lazy evaluation for bool.
type lazyBool struct {
	v bool
	f func() bool
	m sync.Mutex
	o uint32
}

func (v *lazyBool) Get() bool {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Bool provides lazy evaluation for bool. f is called exactly
// once, when the result is first used.
func Bool(f func() bool) func() bool {
	return (&lazyBool{f: f}).Get
}

// lazyByte implements lazy evaluation for byte.
type lazyByte struct {
	v byte
	f func() byte
	m sync.Mutex
	o uint32
}

func (v *lazyByte) Get() byte {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Byte provides lazy evaluation for byte. f is called exactly
// once, when the result is first used.
func Byte(f func() byte) func() byte {
	return (&lazyByte{f: f}).Get
}

// lazyComplex64 implements lazy evaluation for complex64.
type lazyComplex64 struct {
	v complex64
	f func() complex64
	m sync.Mutex
	o uint32
}

func (v *lazyComplex64) Get() complex64 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Complex64 provides lazy evaluation for complex64. f is called exactly
// once, when the result is first used.
func Complex64(f func() complex64) func() complex64 {
	return (&lazyComplex64{f: f}).Get
}

// lazyComplex128 implements lazy evaluation for complex128.
type lazyComplex128 struct {
	v complex128
	f func() complex128
	m sync.Mutex
	o uint32
}

func (v *lazyComplex128) Get() complex128 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Complex128 provides lazy evaluation for complex128. f is called exactly
// once, when the result is first used.
func Complex128(f func() complex128) func() complex128 {
	return (&lazyComplex128{f: f}).Get
}

// lazyFloat32 implements lazy evaluation for float32.
type lazyFloat32 struct {
	v float32
	f func() float32
	m sync.Mutex
	o uint32
}

func (v *lazyFloat32) Get() float32 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Float32 provides lazy evaluation for float32. f is called exactly
// once, when the result is first used.
func Float32(f func() float32) func() float32 {
	return (&lazyFloat32{f: f}).Get
}

// lazyFloat64 implements lazy evaluation for float64.
type lazyFloat64 struct {
	v float64
	f func() float64
	m sync.Mutex
	o uint32
}

func (v *lazyFloat64) Get() float64 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Float64 provides lazy evaluation for float64. f is called exactly
// once, when the result is first used.
func Float64(f func() float64) func() float64 {
	return (&lazyFloat64{f: f}).Get
}

// lazyError implements lazy evaluation for error.
type lazyError struct {
	v error
	f func() error
	m sync.Mutex
	o uint32
}

func (v *lazyError) Get() error {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Error provides lazy evaluation for error. f is called exactly
// once, when the result is first used.
func Error(f func() error) func() error {
	return (&lazyError{f: f}).Get
}

// lazyInt implements lazy evaluation for int.
type lazyInt struct {
	v int
	f func() int
	m sync.Mutex
	o uint32
}

func (v *lazyInt) Get() int {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Int provides lazy evaluation for int. f is called exactly
// once, when the result is first used.
func Int(f func() int) func() int {
	return (&lazyInt{f: f}).Get
}

// lazyInt8 implements lazy evaluation for int8.
type lazyInt8 struct {
	v int8
	f func() int8
	m sync.Mutex
	o uint32
}

func (v *lazyInt8) Get() int8 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Int8 provides lazy evaluation for int8. f is called exactly
// once, when the result is first used.
func Int8(f func() int8) func() int8 {
	return (&lazyInt8{f: f}).Get
}

// lazyInt16 implements lazy evaluation for int16.
type lazyInt16 struct {
	v int16
	f func() int16
	m sync.Mutex
	o uint32
}

func (v *lazyInt16) Get() int16 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Int16 provides lazy evaluation for int16. f is called exactly
// once, when the result is first used.
func Int16(f func() int16) func() int16 {
	return (&lazyInt16{f: f}).Get
}

// lazyInt32 implements lazy evaluation for int32.
type lazyInt32 struct {
	v int32
	f func() int32
	m sync.Mutex
	o uint32
}

func (v *lazyInt32) Get() int32 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Int32 provides lazy evaluation for int32. f is called exactly
// once, when the result is first used.
func Int32(f func() int32) func() int32 {
	return (&lazyInt32{f: f}).Get
}

// lazyInt64 implements lazy evaluation for int64.
type lazyInt64 struct {
	v int64
	f func() int64
	m sync.Mutex
	o uint32
}

func (v *lazyInt64) Get() int64 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Int64 provides lazy evaluation for int64. f is called exactly
// once, when the result is first used.
func Int64(f func() int64) func() int64 {
	return (&lazyInt64{f: f}).Get
}

// lazyInterface implements lazy evaluation for interface{}.
type lazyInterface struct {
	v interface{}
	f func() interface{}
	m sync.Mutex
	o uint32
}

func (v *lazyInterface) Get() interface{} {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Interface provides lazy evaluation for interface{}. f is called exactly
// once, when the result is first used.
func Interface(f func() interface{}) func() interface{} {
	return (&lazyInterface{f: f}).Get
}

// lazyRune implements lazy evaluation for rune.
type lazyRune struct {
	v rune
	f func() rune
	m sync.Mutex
	o uint32
}

func (v *lazyRune) Get() rune {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Rune provides lazy evaluation for rune. f is called exactly
// once, when the result is first used.
func Rune(f func() rune) func() rune {
	return (&lazyRune{f: f}).Get
}

// lazyString implements lazy evaluation for string.
type lazyString struct {
	v string
	f func() string
	m sync.Mutex
	o uint32
}

func (v *lazyString) Get() string {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// String provides lazy evaluation for string. f is called exactly
// once, when the result is first used.
func String(f func() string) func() string {
	return (&lazyString{f: f}).Get
}

// lazyUint implements lazy evaluation for uint.
type lazyUint struct {
	v uint
	f func() uint
	m sync.Mutex
	o uint32
}

func (v *lazyUint) Get() uint {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Uint provides lazy evaluation for uint. f is called exactly
// once, when the result is first used.
func Uint(f func() uint) func() uint {
	return (&lazyUint{f: f}).Get
}

// lazyUint8 implements lazy evaluation for uint8.
type lazyUint8 struct {
	v uint8
	f func() uint8
	m sync.Mutex
	o uint32
}

func (v *lazyUint8) Get() uint8 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Uint8 provides lazy evaluation for uint8. f is called exactly
// once, when the result is first used.
func Uint8(f func() uint8) func() uint8 {
	return (&lazyUint8{f: f}).Get
}

// lazyUint16 implements lazy evaluation for uint16.
type lazyUint16 struct {
	v uint16
	f func() uint16
	m sync.Mutex
	o uint32
}

func (v *lazyUint16) Get() uint16 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Uint16 provides lazy evaluation for uint16. f is called exactly
// once, when the result is first used.
func Uint16(f func() uint16) func() uint16 {
	return (&lazyUint16{f: f}).Get
}

// lazyUint32 implements lazy evaluation for uint32.
type lazyUint32 struct {
	v uint32
	f func() uint32
	m sync.Mutex
	o uint32
}

func (v *lazyUint32) Get() uint32 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Uint32 provides lazy evaluation for uint32. f is called exactly
// once, when the result is first used.
func Uint32(f func() uint32) func() uint32 {
	return (&lazyUint32{f: f}).Get
}

// lazyUint64 implements lazy evaluation for uint64.
type lazyUint64 struct {
	v uint64
	f func() uint64
	m sync.Mutex
	o uint32
}

func (v *lazyUint64) Get() uint64 {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Uint64 provides lazy evaluation for uint64. f is called exactly
// once, when the result is first used.
func Uint64(f func() uint64) func() uint64 {
	return (&lazyUint64{f: f}).Get
}

// lazyUintptr implements lazy evaluation for uintptr.
type lazyUintptr struct {
	v uintptr
	f func() uintptr
	m sync.Mutex
	o uint32
}

func (v *lazyUintptr) Get() uintptr {
	if atomic.LoadUint32(&v.o) == 0 {
		return v.v
	}

	v.m.Lock()
	defer v.m.Unlock()

	if v.o == 0 {
		v.v = v.f()
		v.o = 1
		v.f = nil
	}
	return v.v
}

// Uintptr provides lazy evaluation for uintptr. f is called exactly
// once, when the result is first used.
func Uintptr(f func() uintptr) func() uintptr {
	return (&lazyUintptr{f: f}).Get
}
